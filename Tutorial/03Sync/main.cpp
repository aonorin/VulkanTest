/* В этом уроке теперь присутствует класс Render, из которого мы будем доставать всю необходимую информацию,
 * а также класс Logger,  котором покажем, как можно в DebugReport использовать pUserData.
 * Этот урок расскажет о четырёх видах примитивов синхронизации:
 * заборы, семафоры, события и барьеры.
 * Если вы заметили ошибку, прошу об этом сообщить на форум или лично мне.
 * Все интересующие вас подробности смотрите здесь:
 * https://www.khronos.org/registry/vulkan/specs/1.0-wsi_extensions/pdf/vkspec.pdf
 * © Серый Волк.
*/
#include "common.h"
#include "Render.h"
#include "Logger.h"

int main()
{
	/* Для начала организуем небольшую подготвку, чтобы было, на чём показать синхронизацию.
	 * Ниже есть небольшие пояснения.
	*/
	Render r; //объект, отвечающий за отрисовку
	Logger logger; //логгер, отвечает за вывод на экран и в файл сообщения Vulkan
	r.EnableDebug(true); //включение отладки
	r.AddInstanceLayer("VK_LAYER_LUNARG_standard_validation"); //добавление проверочных слоёв
	r.AddDeviceLayer("VK_LAYER_LUNARG_standard_validation");
	r.CreateInstance(); //создание экземпляра
	logger.Init(r.GetInstance()); //инициализация (получение Vulkan функций)
	logger.AttachLogger(r.GetInstance()); //присоединение callback
	r.CreateDevice(); //создание устройства
	VkQueue queue = r.GetQueue(0); //получение очереди
	VkCommandPool pool = r.CreateCommandPool(true, false); //создание пула
	//Далее, создадим два буфера и запишем в них команды.
	VkCommandBuffer command_buffers[2];
	VkCommandBufferAllocateInfo command_buffers_info;
	ZM(command_buffers_info);
	command_buffers_info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
	command_buffers_info.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY; //первичный буфер
	command_buffers_info.commandPool = pool; //пул, с которого будем выделять буферы.
	command_buffers_info.commandBufferCount = 2; //кол-во командных буферов
	if (vkAllocateCommandBuffers(r.GetDevice(), &command_buffers_info, command_buffers) != VK_SUCCESS)
		return 1;
	//и запишем в них простые команды.
	VkCommandBufferBeginInfo begin_info;
	ZM(begin_info);
	begin_info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
	for (uint8_t i = 0; i < 2; i++)
	{
		vkBeginCommandBuffer(command_buffers[i], &begin_info);
		VkViewport viewport;
		viewport.x = 0;
		viewport.y = 0;
		viewport.width = 1024;
		viewport.height = 768;
		viewport.minDepth = 0;
		viewport.maxDepth = 1;
		vkCmdSetViewport(command_buffers[i], 0, 1, &viewport);
		vkEndCommandBuffer(command_buffers[i]);
	}
	//Заполним инофрмацию о посылке
	VkSubmitInfo submit_info[2];
	for (uint8_t i = 0; i < 2; i++)
	{
		ZM(submit_info[i]);
		submit_info[i].sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
		submit_info[i].commandBufferCount = 1; //кол-во буферов, которые мы хотим отправить
		submit_info[i].pCommandBuffers = &command_buffers[i]; //буферы
	}
	//--------------------------------------------------------------------------------------
	//Заборы (fences)
	//--------------------------------------------------------------------------------------
	VkFence fence = VK_NULL_HANDLE;
	VkFenceCreateInfo fence_create_info;
	ZM(fence_create_info);
	fence_create_info.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;
	vkCreateFence(r.GetDevice(), &fence_create_info, NULL, &fence);

	vkQueueSubmit(queue, 1, &submit_info[0], fence);
	if (vkWaitForFences(r.GetDevice(), 1, &fence, false, VK_WHOLE_SIZE) != VK_SUCCESS)
		return 2;
	vkResetFences(r.GetDevice(), 1, &fence) != VK_SUCCESS
	if (vkWaitForFences(r.GetDevice(), 1, &fence, false, 0) != VK_TIMEOUT)
		return 3;
	vkDestroyFence(r.GetDevice(), fence, NULL);
	//Функция значения не возвращает
	//--------------------------------------------------------------------------------------
	//Семафоры (semaphores)
	//--------------------------------------------------------------------------------------
	/* И так, если забор, это примитивный способ ожидания устройства, то семафор — способ синхронизации
	 * внутри устройства, т.е. даже проверить состояние на хосте уже нельзя. Но не смотря на свою примитивность, эта вещь
	 * весьма полезная. Используется для того, чтобы разные команды не мешали друг друг читать и записывать данные, а также
	 * в некоторых случаях для редких ресурсов (о них будет расказано в следующих уроках).
	 * Что делает семафор: он заставляет ждать выполнение команд в буфере, пока команды другого буфера не достигнут какой-то
	 * определённой точки. Точка определяется конвейером (pipeline) Vulkan (подробнее о конвейре будет рассказно в следующих
	 * уроках). Но всё же расскажу о них вкратце. В предыдущем уроке было рассказно, что команды выполняются независимо друг
	 * от друга как между буферами, так и внутри них. Но, так или иначе, некоторые принадлежат определённым стадиям конвейера,
	 * и основываясь на этом и самому конвейеру, Vulkan и делает выводы.
	 * Теперь нужно создать один семафор.
	 * Как ни странно, но даже если тут и есть подобие флагов... то даже они зарезервированы для будущего испольования
	 * и сейчас их просто нет!
	*/
	VkSemaphore semaphore = VK_NULL_HANDLE;
	VkSemaphoreCreateInfo semaphore_info;
	ZM(semaphore_info);
	semaphore_info.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;
	vkCreateSemaphore(r.GetDevice(), &semaphore_info, NULL, &semaphore);
	/* А теперь нужно сделать так, чтобы первый сначала выполнились команды из первого буфера, затем из второго.
	 * Для этого надо правильно заполнить структуры VkSubmitInfo. В одной мы будем сигнализировать наш семафор,
	 * в другой будем ждать его. Так как мы уже изнаально настроили структуры, нам остаётся их только подкорректировать.
	 * Коррекируем: настроем первый submit на подачу сигнала. Здесь всё относительно просто.
	*/
	submit_info[0].signalSemaphoreCount = 1; //кол-во семафоров, которые надо просигнались
	submit_info[0].pSignalSemaphores = &semaphore ; //сами семафоры
	// Теперь настроем второй submit на ожидание.
	submit_info[1].waitSemaphoreCount = 1; //кол-во семафоров, которые надо ждать
	submit_info[1].pWaitSemaphores = &semaphore; //сами семафоры
	/* А теперь вкусненькое. Дальше нужно указать маску ожидания для каждого из семафоров.
	 * Маска настраивается с помощью VkPipelineStageFlags флагов. Так как мы хотим подождать выполнение всех команд,
	 * поэтому поставим VK_PIPELINE_STAGE_ALL_COMMANDS_BIT.
	*/
	VkPipelineStageFlags semaphore_wait_masks[1] = {VK_PIPELINE_STAGE_ALL_COMMANDS_BIT};
	submit_info[1].pWaitDstStageMask = semaphore_wait_masks;
	/* Можно также подождать и завершения лишь одной части конвейера, указав для этого специальный флаг. Но об этом
	 * в следующих уроках.
	 *
	 * Посылаем наши буферы в очередь.
	*/
	vkQueueSubmit(queue, 2, submit_info, VK_NULL_HANDLE);
	/* Теперь эти буферы выполнятся по очереди. Хотите пруф? А не будет вам. Пока что просто поверьте наслово.
	 *
	 * Теперь можно уничтожить семафор. Но всё равно помните, что для начала, нужно подождать завершения
	 * всех командных буферов, которые используют этот семафор. Я снова воспользуюсь простой функцией
	 * ожидания заверешения команд во всей очереди. Удобная вещь, когда хочешь полностью закночить с чем-то работу.
	*/
	vkQueueWaitIdle(queue);
	vkDestroySemaphore(r.GetDevice(), semaphore, NULL);
	//--------------------------------------------------------------------------------------
	//События (events)
	//--------------------------------------------------------------------------------------
	/* Для начала немного разберёмся в терминологии, которую нам преподносит спецификация Vulkan.
	 * Есть так называемые зависимости выполнения, когда одни команды зависят от выполнения других. В таком случае,
	 * есть команды, от которых зависят другие (первый сет команд, first commands set), и команды, которые зависят от
	 * первых (второй сет команд, second commands set). Почему же нужны такие зависимсоти? Дело в том, что когда вы записали
	 * команды в буфер, это не гарантирует того, что все команды будут выполнятся поочерёдно и соответственно, это не гарантирует
	 * правильного доуступа к памяти.
	 * В случае событий, первый сет — это команды до vkCmdSetEvent, а второй — команды после vkCmdWaitEvents.
	 *
	 * У событий особая роль: они могут быть сигнализированы как в устройстве, так и на хосте, и проверены
	 * как внутри утройства с помощью команды, так и с помощью функции на хосте. Но с некоторой оговоркой.
	 * Ждать хост устройство может спокойно, а вот ждать видеокарту хосту не стоит. Он, конечно, может проверить состояние
	 * события с помощью vkGetEventStatus(device, event), но проверяет он не определённый статус конвейера, а есть ли сигнал вообще.
	 * Да, события также настраиваются на позицию конвейера, как и семафоры, но события, так или иначе, более гибкие, или, как
	 * уже говорилось в нескольких источниках, события — инструмент тонкой настройки синхронизации.
	*/
	//Создадим события
	VkEvent events[2];
	//pNext и флаги зарезервированы для будущего использвания. Сейчас всё по нулям.
	VkEventCreateInfo event_create_info;
	ZM(event_create_info);
	event_create_info.sType = VK_STRUCTURE_TYPE_EVENT_CREATE_INFO;
	for (uint8_t i = 0; i < 2; i++)
	{
		events[i] = VK_NULL_HANDLE;
		//проверять на ошибки в данном случае не будем. мне лень.
		vkCreateEvent(r.GetDevice(), &event_create_info, NULL, &events[i]);
	}
	/* И так, про функцию. Возвращает при удаче два значения
	 * VK_EVENT_RESET — если событие не просигналено
	 * VK_EVENT_SET — если наборот — просигналено.
	 * Можем даже сейчас проверить:
	*/
	if (vkGetEventStatus(r.GetDevice(), events[0]) != VK_EVENT_RESET)
		return 6;
	/* Теперь попробуем подождать событие внутри устройства.
	 * Для начала в submit info уберём информацию о семафорах. Для этого просто скажем, что их кол-во равняется 0.
	 * После этого маски и хэндлы будут игнорироваться.
	*/
	submit_info[0].signalSemaphoreCount = 0;
	submit_info[1].waitSemaphoreCount = 0;
	vkBeginCommandBuffer(command_buffers[0], &begin_info);
	/* Посмотрим на команду ожидания событий:
	*/
	vkCmdWaitEvents(command_buffers[0], //указываем буфер, которому нужно ждать.
		1, //указываем кол-во событий
		&events[0], //сами события
		/* Указываем, что мы ждём. В данном случае, мы ждём хост.
		 * Также, можно настроить на ожидание другого буфера команд, но для этого нужно указать флаги
		 * позиции конвейера, при котором этот буфер сигналит события.
		 * Как бы то ни было, слой DrawState может ругаться на этот параметр (баг).
		*/
		VK_PIPELINE_STAGE_HOST_BIT,
		/* Позиции конвейера, которые ждут просигналеных событий. В данном случае, мы указываем самое начало.
		 * То есть, буфер не начнёт выполняться, пока мы не подадим сигнал.
		*/
		VK_PIPELINE_STAGE_ALL_COMMANDS_BIT,
		//Далее идут барьеры, о которых мы поговорим позже
		0, NULL, //кол-во и барьеры памяти
		0, NULL, //кол-во и барьеры буферов
		0, NULL //кол-во и барьеры изображений
		);
	vkEndCommandBuffer(command_buffers[0]);
	//Теперь отсылаем буфер.
	vkQueueSubmit(queue, 1, &submit_info[0], VK_NULL_HANDLE);
	/* Всё, наше устройство ждёт момента, когда мы просигналим ей.
	 * Для подачи сигнала нужно использовать следующую функцию:
	*/
	if (vkSetEvent(r.GetDevice(), events[0]) != VK_SUCCESS)
		return 7;
	/* Здесь всё просто. Первым параметром устройство, вторым — хэндл события.
	 * Теперь нужно подождать, пока всё выполниться.
	*/
	vkQueueWaitIdle(queue);
	//Также можно вернуть события в обычное состояние.
	vkResetEvent(r.GetDevice(), events[0]);
	/* Также, есть следующие команды:
	 * vkCmdSetEvent(buffer, event, stage)
	 * Которое переведёт событие в просигналеное состояние, когда конвейер достигнет позиции stage.
	 * И наоборот, вернёт событие в обычное состояние следующая команда:
	 * vkCmdResetEvent(buffer, event, stage), которая также работает при достижении определённой позиции конвейера.
	 * Уничтожим события.
	*/
	for (uint8_t i = 0; i < 2; i++)
	{
		vkDestroyEvent(r.GetDevice(), events[i], NULL);
	}
	//--------------------------------------------------------------------------------------
	//Барьеры, зависимости
	//--------------------------------------------------------------------------------------
	/* Кроме событий есть также и более простой способ сделать такую зависимость: барьер.
	 * Барьеры фактически позволяют защитить какие-либо участки кода от несвоевременного чтения, выполнения и записи
	 * в командном буфере. Напомню, что некоторые команды внутри одного буфера могут выполнятся не по порядку,
	 * преждевременно или одновременно с другими, во благо оптимизации/ускорения процесса отрисовки кадры.
	 * Когда такое нежелательно и нужно защитить участки, которые должны успеть выполниться, прежде чем их результат
	 * будет использован где-либо ещё, существуют барьеры.
	 * И они бывают 2 типов:
	 * Барьер выполнения.
	 * Барьер памяти.
	 * В свою очередь барьеры памяти разделяются на:
	 * Барьер глобальной памяти
	 * Барьер буферов
	 * Барьер изображений
	 * Барьеры памяти могут использовать как барьеры выполнения, так и события.
	 * Барьер выполнения также разделяет команды на до него (первый сэт), и после него (второй сэт). Он фактически блокирует
	 * выполнение команд дальше, пока в командном буфере не выполнятся все команды определённой стадии,
	 * так как последующие команды зависят от её результата. Таким образом, мы избегаем несвоевременного выполнения команд.
	 * А также можно защитить память от несвоевременного доступа, используая вместе с барьером конвейера барьеры памяти,
	 * которые защищают память от несвоевременного использования.
	*/
	vkBeginCommandBuffer(command_buffers[0], &begin_info);
	//здесь, допустим, первый сет команд
	vkCmdPipelineBarrier(command_buffers[0],
		/* Немного о следующих двух параметрах дальше.
		 * В первый мы должны поместить стадию (или стадии), которая должна обязательно выполнится,
		 * прежде чем применятся последующие команды, пренадлежащие стадиям во втором.
		 * Также эти параметры имеют свою роль и в барьерах памяти.
		*/
		VK_PIPELINE_STAGE_VERTEX_SHADER_BIT,
		VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT,
		0,
		0, NULL,
		0, NULL,
		0, NULL);
	//а здесь идёт второй сет команд.
	vkEndCommandBuffer(command_buffers[0]);
	vkQueueSubmit(queue, 1, &submit_info[0], VK_NULL_HANDLE);
	vkQueueWaitIdle(queue);
	/* Подробнее о барьерах я расскажу в одном из следующих уроках, так как лучше их показать на более нагляддном примере.
	 * А сейчас это всего лишь небольшое объяснение их работы.
	*/
	//--------------------------------------------------------------------------------------
	r.DestroyCommandPool(pool);
	r.DestroyDevice();
	logger.DetachLogger(r.GetInstance());
	r.DestroyInstance();
	return 0;
}

/* В общем, спасибо, что уделили этому уроку время. Khronos Group, Niko Kauppi, и тем, кто делает примеры — Большое Спасибо!
 * А дальше классика:
 * Если вы хотите меня поддержать, прикрепляю кошель с Я.Денег:
 * 410012557544062
 * Ну или просто жмя по ссылке:
 * https://money.yandex.ru/to/410012557544062
 * Хе-хе.
*/
