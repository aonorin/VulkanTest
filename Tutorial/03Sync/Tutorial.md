| | | |
|:---|:---:|---:|
|[Назад][Prev]|[Наверх][Up]|[Вперёд][Next]|

#Синхронизация в Vulkan
Вспомним некоторые вещи из предыдущего урока: заполненые командами буферы поступают в очередь, после этого эти команды запускаются, но не ждут другие команды, т.е. в Vulkan каждая команда не зависит друг от друга, также, не зависит друг от друга устройство и хост — они работают параллельно друг другу, т.е. при отправке команд в устройство, хост не ждёт выполнения всех команд, а работа его продолжается. Но есть инструменты Vulkan'а, которые позволяют синхронизировать хост и девайс, команды и т.д — это 4 примитима синхронизации:
+ **Забор** (*fence*) — самый примитивный примитив. Позволяет проверить с хсста выполнение какого-либо процесса на устройстве (выполнились ли командные буферы, например).
+ **Семафор** (*semaphores*) — позволяет синхронизировать выполнение командных буферов на устройстве. Но синхронизировать хост и устройство с помощью них нельзя.
+ **Событие** (*event*) — тонкая настройка — можно настроить зависимости между хостом, устройством, командами и т.д.
+ **Барьер** (*barrier*) — создаёт зависимости между наборами команд.

Каждый примитив может находится в двух состояниях:
+ **Не-сигнальное** (*unsignaled*) — обычное состояние примитива. Фактически означает, что ничего важного для этого примитива не произошло.
+ **Сигнальное** (*signaled*) — состояние, которое означает, что произошло что-то, на что примитив был настроен.

##Забор
На данный момент, забор может использоваться в 3 местах:
+ Посылка командных буферов в очередь.
+ Асссоциирование разрежженых ресурсов.
+ Ожидание доступности изображения из цепочки переключений (WSI: Swapchain).

Так что заборы могут пыть полезны в очень редких случаях. Тем не менее, лучше узнать про них подробнее.
###Создание и уничтожение забора
Для создания забора, нужно заполнить следующую структуру.
``` c++
typedef struct VkFenceCreateInfo {
	VkStructureType sType;
	const void* pNext;
	VkFenceCreateFlags flags;
} VkFenceCreateInfo;
```
+ `sType` — тип структуры, в данном случае `VK_STRUCTURE_TYPE_FENCE_CREATE_INFO`.
+ `pNext` — указатель на ESS.
+ `flags` — флаги создания.

Флаги могут быть такими:
``` c++
typedef enum VkFenceCreateFlagBits {
	VK_FENCE_CREATE_SIGNALED_BIT = 0x00000001,
} VkFenceCreateFlagBits;
```
+ `VK_FENCE_CREATE_SIGNALED_BIT` — означает, что забор должен быть в сигнальном состоянии с самого начала. По умолчанию состояние забора — не-сигнальное.
``` c++
VkResult vkCreateFence(
	VkDevice device,
	const VkFenceCreateInfo* pCreateInfo,
	const VkAllocationCallbacks* pAllocator,
	VkFence* pFence);
```		
+ `device` — хэндл устройства.
+ `pCreateInfo` — информация о создании забора.
+ `pAllocator` — указатель на структуру `VkAllocationCallbacks`, содержащие адреса функций управления памятью.
+ `pFence` — возвращаемый хэндл забора.

Функция может вернуть:

+ `VK_SUCCESS`
+ `VK_ERROR_OUT_OF_HOST_MEMORY`
+ `VK_ERROR_OUT_OF_DEVICE_MEMORY`

Разрушить забор может эта функция:
``` c++
void vkDestroyFence(
	VkDevice device,
	VkFence fence,
	const VkAllocationCallbacks* pAllocator);
```	
+ `device` — хэндл устройства.
+ `fence` — хэндл забора, который необходимо разрушить.
+ `pAllocator` — указатель на структуру `VkAllocationCallbacks`, содержащие адреса функций управления памятью.

Забор нельзя разрушить, если он всё ещё используется.

###Сброс забора
Если один и тот же забор будет использован несколько раз, перед повторным использованием его нужно сбросить. Для этого есть функция:
``` c++
VkResult vkResetFences(
	VkDevice device,
	uint32_t fenceCount,
	const VkFence* pFences);
```	
+ `device` — хэндл устройства.
+ `fenceCount` — количество заборов, которые нужно сбросить.
+ `pFences` — хэндлы заборов (массив).

После этого, все переданные заборы будут переведены в не-сигнальное состояние. Если забор был уже в не-сигнальном состоянии, его сброс не принисёт никакого эффекта. Функция возвращает:

+ `VK_SUCCESS`
+ `VK_ERROR_OUT_OF_HOST_MEMORY`
+ `VK_ERROR_OUT_OF_DEVICE_MEMORY`

###Проверка и ожидание
После отправки забора можно проверить его текущее состояние (без ожидания):
``` c++
VkResult vkGetFenceStatus(
	VkDevice device,
	VkFence fence);
```
+ `device` — хэндл устройства.
+ `fence` — хэндл забора, который необходимо проверить.

Возвращаемые коды:

+ `VK_SUCCESS` — забор просигнален.
+ `VK_NOT_READY` — забор не просигнален.
+ `VK_ERROR_OUT_OF_HOST_MEMORY`
+ `VK_ERROR_OUT_OF_DEVICE_MEMORY`
+ `VK_ERROR_DEVICE_LOST` — устройство потеряно.


А также, можно ждать один и более заборов:
``` c++
VkResult vkWaitForFences(
	VkDevice device,
	uint32_t fenceCount,
	const VkFence* pFences,
	VkBool32 waitAll,
	uint64_t timeout);
```	
+ `device` — хэндл устройства.
+ `fenceCount` — количество заборов, которые нужно ждать.
+ `pFences` — хэндлы заборов (массив).
+ `waitAll` — нужно ли ждать *все* заборы (`VK_TRUE`) или достаточно подожать *один* (`VK_FALSE`). Если забор один, данный параметр не имеет значения.
+ `timeout` — максимальное время ожидания в наносекундах (1 наносекунда — 10<sup>-9</sup> секунд, или 1/1.000.000.000 секунд). При времени ожидания 0 функция проверит состояние забора (или заборов) и сразу же вернёт управление. Если значение максимальное (`VK_WHOLE_SIZE`, или `~0ULL`), то функция будет ждать сигнала бесконечно.

Возвращает:

+ `VK_SUCCESS` — забор(ы) просигнален.
+ `VK_TIMEOUT` — время истекло.
+ `VK_ERROR_OUT_OF_HOST_MEMORY`
+ `VK_ERROR_OUT_OF_DEVICE_MEMORY`
+ `VK_ERROR_DEVICE_LOST` — устройство потеряно.

###Пример
Создание забора:
``` c++
VkFence fence = VK_NULL_HANDLE;
VkFenceCreateInfo fence_create_info;
ZM(fence_create_info); //zero memory
fence_create_info.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;
vkCreateFence(device, &fence_create_info, NULL, &fence);
```
Отправка команд вместе с забором:
``` c++
//...
vkQueueSubmit(queue, 1, &submit_info, fence);
```
Ожидание забора:
``` c++
vkWaitForFences(device, 1, &fence, false, VK_WHOLE_SIZE);
```
###Гарантии
Забор даёт гарантию на то, что все команды (или что там ещё...) выолнились. Но забор не даёт гарантий на то, что результат этих команд (а именно память) доступна для хоста. Для такой гарантии нужно применить барьер.

##Стадии конвейера и зависимости
###Стадии конвейера
Перед тем, как продолжить, сначала стоит пояснить несколько важных вещей. Конвейер, конечно, можно приостановить на определённой команде, но это бы привело к потере производительности, которой можно избежать. Для этого команды можно приостановить на определённой стадии. О том, как это работает и где можно использовать — чуть позже. А пока о стадиях.
``` c++
typedef enum VkPipelineStageFlagBits {
	VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT = 0x00000001,
	VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT = 0x00000002,
	VK_PIPELINE_STAGE_VERTEX_INPUT_BIT = 0x00000004,
	VK_PIPELINE_STAGE_VERTEX_SHADER_BIT = 0x00000008,
	VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT = 0x00000010,
	VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT = 0x00000020,
	VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT = 0x00000040,
	VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT = 0x00000080,
	VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT = 0x00000100,
	VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT = 0x00000200,
	VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT = 0x00000400,
	VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT = 0x00000800,
	VK_PIPELINE_STAGE_TRANSFER_BIT = 0x00001000,
	VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT = 0x00002000,
	VK_PIPELINE_STAGE_HOST_BIT = 0x00004000,
	VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT = 0x00008000,
	VK_PIPELINE_STAGE_ALL_COMMANDS_BIT = 0x00010000,
} VkPipelineStageFlagBits;
```
Вышеуказанные значения будут использваться как флаги масок, так как можно указывать несколько значений. А сейчас стоит разобрать каждый флаг подробнее.

+ `VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT` — это флаг обозначает стадию конвейера, на которой команды только-только попали в очередь.
+ `VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT` — стадия, где используются данные от DrawInderect или DispatchInderect.
+ `VK_PIPELINE_STAGE_VERTEX_INPUT_BIT` — стадия, на которой используются данные вершинных и индесных буферов.
+ `VK_PIPELINE_STAGE_VERTEX_SHADER_BIT` — стадия, на которой включается вершинный шейдер.
+ `VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT` — на этой стадии включается шейдер контроля тесселяции.
+ `VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT` — стадия шейдера оценки тесселяции.
+ `VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT` — стадия геометрического шейдера.
+ `VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT` — стадия фрагментного (пиксельного шейдера).
+ `VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT` — стадия ранней фрагметной (пиксельной) проверки.
+ `VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT` — стадия поздней фрагметной (пиксельной) проверки.
+ `VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT` — стадия после смешивания (blending), когда подаются финальные значения на выход из конвейера. Эта стадия также включает в себя *resolve* операцию, которая происходит в конце подпрохода.
+ `VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT` — стадия, на которой запускается вычеслительный шейдер.
+ `VK_PIPELINE_STAGE_TRANSFER_BIT` — стадия, на которой выполняются команды копирования. Это такие команды, как:
  + `vkCmdCopyBuffer`
  + `vkCmdCopyImage`
  + `vkCmdBlitImage`
  + `vkCmdCopyBufferToImage`
  + `vkCmdCopyImageToBuffer`
  + `vkCmdUpdateBuffer`
  + `vkCmdFillBuffer`
  + `vkCmdClearColorImage`
  + `vkCmdClearDepthStencilImage`
  + `vkCmdResolveImage`
  + `vkCmdCopyQueryPoolResults`
+ `VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT` — завершающая стадия конвейера, где команды завершили своё исполнение.
+ `VK_PIPELINE_STAGE_HOST_BIT` — псевдо-стадия, означающая что хост будет читать/записывать память устройства.
+ `VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT` — работа всех графических стадий.
+ `VK_PIPELINE_STAGE_ALL_COMMANDS_BIT` — работа всех стадий, поддерживаемых очередью.

**Заметка 1.**
К слову, `VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT` и `VK_PIPELINE_STAGE_ALL_COMMANDS_BIT` не одно и тоже, что и `VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT`. А именно, если `VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT` не задерживает другие стадии (так как сам флаг означает только одну), то флаги *All* будут (так как означают несколько стадий). Также, объявляя зависимость памяти, память будет доступна и/или видима на всех стадиях, если поставлен флаг *all*, в то время как флаг конца конвейера этого не означает, так как фактически не содержит в себе рабочую стадию. `VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT` можно использовать, дабы убедится в завершении конвейера.

**Заметка 2.**
Если импементация не может обновить состояние события на завершении текущей стадии, имплементация может сделать это по завершению следующей (к примеру, вместо сигнала после вершинного шейдера, сигнал после *color attachment*). Лимит — все графические команды. Также, если имплементация не может ждать определённую стадию, она будет ждать логически более раннюю стадию.
Также, если имплементация не может включить зависимость выполнения на определённых стадиях, она может включить зависимость дополнительных исходных (*source*) стадий и/или дополнительных конечных (*destenation*) стадий чтобы сохранить зависимость.
Если в имплементации происходит такое, то это не должно влиять на семантику зависимостей выполнения или памяти или барьеров изображений и буферов.


Некоторые стадии поддерживаются только очередями, которые поддерживают определённый набор операции. Ниже прдставлена таблица, что какие флаги поддержки должны быть у очереди, чтобы поддерживать определённый флаг стадии конвейера. Если во второй колонке указано несколько флагов, это значит, что стадия конвейера будет поддерживаться, если есть поддержка одного из указанных флагов очереди.

|Флаг стадии конвейера | Требуемый флаг возможностей очереди|
| -------------------- | -----------------------------------|
|`VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT`|Нет|
|`VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT`|`VK_QUEUE_GRAPHICS_BIT` или `VK_QUEUE_COMPUTE_BIT`|
|`VK_PIPELINE_STAGE_VERTEX_INPUT_BIT`|`VK_QUEUE_GRAPHICS_BIT`|
|`VK_PIPELINE_STAGE_VERTEX_SHADER_BIT`|`VK_QUEUE_GRAPHICS_BIT`|
|`VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT`|`VK_QUEUE_GRAPHICS_BIT`|
|`VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT`|`VK_QUEUE_GRAPHICS_BIT`|
|`VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT`|`VK_QUEUE_GRAPHICS_BIT`|
|`VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT`|`VK_QUEUE_GRAPHICS_BIT`|
|`VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT`|`VK_QUEUE_GRAPHICS_BIT`|
|`VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT`|`VK_QUEUE_GRAPHICS_BIT`|
|`VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT`|`VK_QUEUE_GRAPHICS_BIT`|
|`VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT`|`VK_QUEUE_COMPUTE_BIT`|
|`VK_PIPELINE_STAGE_TRANSFER_BIT`|`VK_QUEUE_GRAPHICS_BIT`, `VK_QUEUE_COMPUTE_BIT` или `VK_QUEUE_TRANSFER_BIT`|
|`VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT`|Нет|
|`VK_PIPELINE_STAGE_HOST_BIT`|Нет|
|`VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT`|`VK_QUEUE_GRAPHICS_BIT`|
|`VK_PIPELINE_STAGE_ALL_COMMANDS_BIT`|Нет|

###Зависимости
Команды синхронизации позволяют указать **явную** (*explicit*) зависимость между двумя наборами (set) команд, где второй набор команд зависит от первого. Наборами могут быть:
+ Первый набор: перед `vkCmdSetEvent`.<br>
  Второй набор: после `vkCmdWaitEvents` в той же очереди и с тем же событием.
+ Первый набор: команды внутри подпрохода с меньшим индексом (или перед проходом отрисовки).<br>
  Второй набор: команды внутри подпрохода с большим индексом, где прдеставлена зависимость между этими двумя подпроходами (или подпроходом и `VK_SUBPASS_EXTERNAL`).
+ Первый набор: команды перед барьером.<br>
  Второй набор: команды после барьера в той же очереди (по возможности также ограничены одним подпроходом).

**Зависимостью выполнения** (*execution dependency*) называют одиночную зависимость наборов исходных и конечных стадий конвейера, которая гарантирует, что вся работа набора стадий в `srcStageMask` будет выполнена в первом наборе команд, прежде чем будет выполнятся работа набора стадий в `dstStageMask` во втором наборе команд.

**Цепочкой зависимостей выполнения** (*execution dependency chain*) от набора исходных стадий A до набора конечных стадий B называют последовательность зависимостей выполнения послынных в очередь в промежутке между первым набором команд и вторым набором команд, сохраняя следующие условия:
+ первая зависимость включает в себя A или `VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT` или `VK_PIPELINE_STAGE_ALL_COMMANDS_BIT` в `srcStageMask`. И...
+ последняя зависимость включает в себя B или `VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT` или `VK_PIPELINE_STAGE_ALL_COMMANDS_BIT` в `dstStageMask`. И...
+ для каждой зависимости в последовательности (исключая первую) как минимум одна соблюдать следующие условия:
  - `srcStageMask` текущей зависимости включает в себя хотя бы один бит C, который был в `dstStageMask` предыдущей зависимости. Или...
  - `srcStageMask` текущей зависимости включает в себя `VK_PIPELINE_STAGE_ALL_COMMANDS_BIT` или `VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT`. Или...
  - `dstStageMask` предыдущей зависимости включает в себя `VK_PIPELINE_STAGE_ALL_COMMANDS_BIT` или `VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT`. Или...
  - `srcStageMask` текущей зависимости включает в себя `VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT`, а `dstStageMask` предыдущей зависимости включает в себя как минимум один флаг графической стадии конвейера. Или...
  - `dstStageMask` предыдущей зависимости включает в себя  `VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT`, а `srcStageMask` текущей зависимости включает в себя как минимум один флаг графической стадии конвейера.
+ для каждой зависимости в последовательности (исключая первую) как минимум одна соблюдать следующие условия:
  - текущая зависимость — это пара `vkCmdSetEvent`/`vkCmdWaitEvents` (где `vkCmdWaitEvents` может быть как внутри, так и снаружи прохода отрисовки); или `vkCmdPipelineBarrier` снаружи прохода отрисовки; или зависимостью подпрохода отрисовки, где `srcSubpass` равен `VK_SUBPASS_EXTERNAL` для текущего прохода отрисовки, который начиается с команды `vkCmdBeginRenderPass`, где предыдущей зависимостью может быть любая из следующих:
    * пара `vkCmdSetEvent`/`vkCmdWaitEvents`  или `vkCmdPipelineBarrier`, любой из которых находится вне прохода отрисовки, который предшествует текущей зависимости в очереди порядка выполнения. Или...
	* зависимость подпрохода, где `dstSubpass` равен `VK_SUBPASS_EXTERNAL` для прохода отрисовки, который был завершён командой `vkCmdEndRenderPass` и который предшествует текущей зависимости в очереди порядка выполнения.
  - текущая зависимость — это зависимость подпрохода для прохода отрисовки, где предыдущей зависимостью может быть любая из следующих:
    * другая зависимость для того же прохода отрисовки, где `dstSubpass` равен `srcSubpass` текущей зависимости. Или...
	* `vkCmdPipelineBarrier` того же прохода отрисовки, записанный для подпрохода, указанном в `srcSubpass` текущей зависимости. Или...
	* пара `vkCmdSetEvent`/`vkCmdWaitEvents`, где `vkCmdWaitEvents` внутри того же прохода отрисовки и записанный для подпрохода, указанном в `srcSubpass` текущей зависимости.
  - текущая зависимость — `vkCmdPipelineBarrier` внутри подпрохода для прохода отрисвоки, где предыдущей зависимостью может быть любая из следующих:
    * зависимость подпрохода для того же прохода отрисовки, `dstSubpass` равен проходу с `vkCmdPipelineBarrier`. Или...
	* `vkCmdPipelineBarrier` того же прохода отрисовки, записанный для того же подпрохода перед текущей зависимостью. Или...
	* пара `vkCmdSetEvent`/`vkCmdWaitEvents`, где `vkCmdWaitEvents` внутри того же прохода отрисовки и записанный для того же подпрохода перед текущей зависимостью.

Пара последовательных зависимостей выполнения в цепочке зависимостей выполнения выполняет зависимость между стадией A и B с помощью промежуточной стадии C, даже если между ними нет никакой работы, которая включает в себя стадию флага C.

Цепочка зависимостей выполнения гарантирует, что работа стадии конвейера A в первом наборе команд будет завершена, прежде чем любая работа стадии конвейера B начнёт свою работу во втором наборе команд.

Команда C<sub>1</sub> называется **произошедшей-ранее** (*happen-before*) зависимости D<sub>2</sub> для стадии конвейера S если соблюдены следющие условия:
+ C<sub>1</sub> находится в первом наборе команд для зависимости D<sub>1</sub>, которая содержит стадию S в `srcStageMask`. И...
+ существует цепочка зависимостей выполнения, содержащая D<sub>1</sub> и D<sub>2</sub>, где D<sub>2</sub> следует за D<sub>1</sub> в последовательности зависимостей выполнения.

Подобным образом, команда C<sub>2</sub> называется **произошедшей-позднее** (*happen-after*) зависимости выполнения D<sub>1</sub> для стадии конвейера S если соблюдены следющие условия:
+ C<sub>2</sub> находится во втором наборе команд для зависимости D<sub>2</sub>, которая содержит стадию S в `dstStageMask`. И...
+ существует цепочка зависимостей выполнения, содержащая D<sub>1</sub> и D<sub>2</sub>, где D<sub>2</sub> следует за D<sub>1</sub> в последовательности зависимостей выполнения.

Зависимость называется **порегионной** (*by-region*), если параметр `dependencyFlags` включает в себя `VK_DEPENDENCY_BY_REGION_BIT`, такой барьер описывает зависимость по региону (x, y, layer). В этом случае для каждого региона (по отдельности) имплементация должна убедиться, что все исходные стадии первого набора команд выполнятся прежде, чем начнут выполнятся команды второго набора, пренадлежащие конечной стадии для того же регионо. С того момента, как вызовы фрагментных (пиксельных) шейдеров не специальзированы на конкретные размеры, размер региона усматривается имплементацией и не известен приложение, тем не менее, подразумевается, что размер не больше одного пикселя. Если `dependencyFlags` не включает в себя `VK_DEPENDENCY_BY_REGION_BIT`, это описывает глобальную непорегеонную зависимость, где должны быть готовы все пиксельные регионы.

**Зависимости памяти** работают на пару с зависимостями выполнения, синхронизируя доступ к памяти между двумя наборами команд. Они работают согласно двум "половинкам" зависимости, где команды произошедшие ранее зависимости выполнения для `srcStageMask` вместе с командами произошедшими позднее зависимости  для `dstStageMask`, как описано выше. Первая половина зависимости делает доступ к памяти для стадии, указанной в `srcStageMask` таким, как указано в `srcAccessMask`, а также делает записи **доступными** (*available*) для последующих команд. Вторая половина делает записи, произошедшие в предыдущих командах **видимыми** (*visible*) для стадий `dstStageMask` второго набора команд, используя указания в `dstAccessMask`, если эти записи стали доступными в первом наборе команде текущей или предыдущей зависимости. Две половинки зависимости памяти могут быть выражены как часть одной команды или частью отдельных барьеров на столько, на сколько распространяется цепочка зависимостей выполнения между ними. Приложение должно использовать зависимости памяти чтобы сделать сделанные записи видимыми прежде, чем последующее чтения могут их использовать, и прежде чем последующие записи могут их перезаписать. Если не соблюдать эти правила, то результат чтения будет неопределённый, и порядок записей будет также неопределённым.

Глобальные барьеры памяти применяются ко всем ресурсам, принадлежащие устройству. Барьеры памяти буферов и изображений распростряняются на диапозон(-ы) буфера или подгруппу(-ы) изображения (*image subresource(s)*) включённые в команду. Для доступа к байту буфера или погруппы изображения, синхронизированными между двумя наборами команд, байт или погруппа должны быть включены в первую и вторую половину зависимости, как это описано выше, но не должны быть включены в каждый шаг цепочки зависимости выполнения между ними. 

Цепочка зависимостей выполнения называется **порегионной** (*by-region*), если все стадии во всех зависимостях цепочки находятся в пространстве стадий конвейера, принадлежащие отрисовке кадра (framebuffer), а также `VK_DEPENDENCY_BY_REGION_BIT` включён во все зависимости цеопчки. В противном случае, цепочка зависимостей не является порегионной. Две половины зависимостей памяти формируют порегионную зависимость, если все цепочки зависимостей выполнения между ними порегионные. Другими словами, если между двумя наборами команд находится непорегионная зависимость, зависимость памяти также не может считаться порегионной.

Когда барьер памяти включает в себя переход макета (layout transition), барьер сначала делает записи с помощью `srcStageMask` и `srcAccessMask` доступными, затем делает переход макета, затем содержимое нового макета видимо для доступа в `dstStageMask` и `dstAccessMask`, будто если здесь была бы как зависимость выполнения и памяти между исходными масками и переходом, так и зависимость выполнения и памяти между пеходом и конечными масками. Все записи до этого, ставшие доступными будут включены в переход макета, но любые предыдущие записи, не ставшие доступными, могут потеряться или повредить изображение.

Любые зависимости должны как минимум включать в себя хотя бы один флаг в `srcStageMask` и `dstStageMask`.

Зависимости нужны для того, чтобы решить проблему с опасными ситуациями с данными, к примеру чтобы убедится что операции записи стали видимыми для последующих операций чтения (**опасность в чтении-после-записи** (*read-after-write hazard*)), так и решить проблемы с записью-после-записи. Запись-после-чтения и чтение-после-чтение требуют только зависимость выполнения (зависимости памяти им не нужны).
###Что?
Огромный текст теории и ноль практики... действительно непонятно (хотя кому как). Но давайте не будем особо спешить со сложными зависимостями, а просто продолжим понемногу осваивать Vulkan.

##Семафор
Семафоры используются, чтобы синхронизировать посылки (например, командных буферов) в очередь. Менять статус с сигнального на не-сигнальный и обратно могут только очереди (хост не может этого делать), а также ожидаются они только очередями.

Структура, содержащая информацию о семафоре:
``` c++
typedef struct VkSemaphoreCreateInfo {
	VkStructureType sType;
	const void* pNext;
	VkSemaphoreCreateFlags flags;
} VkSemaphoreCreateInfo;
```

+ `sType` — тип структуры, в данном случае `VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO`.
+ `pNext` — указатель на ESS.
+ `flags` — флаги (на данный момент отсутствуют) — `0`.

Чтобы создать семафор, нужна следующая функция:
``` c++
VkResult vkCreateSemaphore(
	VkDevice device,
	const VkSemaphoreCreateInfo* pCreateInfo,
	const VkAllocationCallbacks* pAllocator,
	VkSemaphore* pSemaphore);
```

+ `device` — хэндл устройства.
+ `pCreateInfo` — структура, содержащая информацию о семафоре.
+ `pAllocator` — указатель на структуру `VkAllocationCallbacks`, содержащие адреса функций управления памятью.
+ `pSemaphore` — возвращаемый хэндл семафора.

Разрушение семафора:

``` c++
void vkDestroySemaphore(
	VkDevice device,
	VkSemaphore semaphore,
	const VkAllocationCallbacks* pAllocator);
```

+ `device` — хэндл устройства.
+ `semaphore` — хэндл семафора.
+ `pAllocator` — указатель на структуру `VkAllocationCallbacks`, содержащие адреса функций управления памятью.

###Пример

Для начала создадим семафор:
``` c++

VkSemaphore semaphrore = VK_NULL_HANDLE;
VkSemaphoreCreateInfo sem_info = {
	VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO, // -> sType
	nullptr, // -> pNext
	0 }; // -> flags
if (vkCreateSemaphore(device, &sem_info, nullptr, &semaphore) != VK_SUCCESS)
	return;
```

Настройка посылок на семафор:
``` c++
VkSubmitInfo submit_info[2];
memset(submit_info, 0, sizeof(VkSubmitInfo) * 2);
//...
//первый подаст сигнал при завершении работы, для этого указываем:
submit_info[0].signalSemaphoreCount = 1; //сколько семафоров нужно просигналить, при завершении работы этой пачки (именно пачки, группы) буферов
//указываем, какие семафоры нужно просигналить
VkSemaphore sems[] = {semaphrore}; //если семафор один, этим массивом можно не заморачиваться
submit_info[0].pSignalSemaphores = sems; 
//...
//второй будет ждать сигнал семафора, прежде чем вторая группа буферов начнёт работу над, допустим, фрагментным (пиксельным) шейдером
submit_info[1].waitSemaphoreCount = 1; // эта пачка будет ждать только один семафор
/* Так мы задаём маски ожидания для семафоров. Вся пачка будет ждать сигнала семафора, перед тем,
как начать работу над фрагментным (пиксельном) шейдером.*/
VkPipelineStageFlags wait_flags[] = {VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT};
submit_info[1].pWaitDstStageMask = wait_flags;
//и затем нужно задать сами семафоры, которые пачка будет ждать.
submit_info[1].pWaitSemaphores = sems;
//...
```

Отправка групп буферов:
``` c++
//...
vkQueueSubmit(queue, 2, submit_info, VK_NULL_HANDLE);
```

После этого, первая и вторая группа будут выполнятся, но затем, если первая группа всё ещё выполняется, вторая группа будет ждать сигнала, прежде чем начнёт выполнять фрагментный шейдер. После того, как первая группа выполнилась, семафор будет просигнален и фрагментный шейдер запуститься. Если всё же первая группа выполнилась быстрее, прежде чем вторая достигла фрагментного шейдера, то ожидания не будет и шейдер начнёт свою работу сразу (так как семафор находится уже в сигнальном состоянии). 

##Событие
##Барьер
##Гарантии порядка записей хоста

| | | |
|:---|:---:|---:|
|[Назад][Prev]|[Наверх][Up]|[Вперёд][Next]|

[К Readme][Readme]

[Up]: ../Readme.md "Наверх"
[Prev]: ../02Commands/Tutorial.md "Назад"
[Next]: ../04WSI/Tutorial.md "Вперёд"
[Readme]: ./Readme.md "К Readme"